<!DOCTYPE html>
<html>
	<head>
		<title>Virtual Keyboard GUI</title>
		<style>
			:root {
				font-size: 12px;
			}
			* {
				box-sizing: border-box;
			}
			body {
				position: fixed;
				top: 0;
				left: 0;
				width: 100vw;
				height: 100vh;
				overflow: none;
				margin: 0;
				padding: 0;
				
				display: grid;
				grid-template-areas: "scroll" "keyboard";
				grid-template-rows: 1fr calc(min(10vw, 100vh));
			}
			
			#scroll, #scroll-overlay {
				grid-area: scroll;
				height: 100%;
				width: 100%;
				min-height: 0;
				min-width: 0;

				background: #000;
			}
			#scroll-overlay {
				background: linear-gradient(#000A, #0008 10%, #5434 60%, #8763 80%, #FFF2);
			}
			#keyboard, #keyboard-bg {
				grid-area: keyboard;
				width: 100%;
				height: 100%;
				min-height: 0;
				min-width: 0;
			}
			#keyboard {
				background: linear-gradient(#FFF4, #8884 2px, #0000 6px, #0000 70%, #2102);
			}
		</style>
	</head>
	<body>
		<canvas id="scroll"></canvas>
		<canvas id="scroll-overlay"></canvas>
		<canvas id="keyboard-bg"></canvas>
		<canvas id="keyboard"></canvas>
		
		<script src="cbor.min.js"></script>
		<script>
			let blackPattern = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0];
			let whitePattern = [0, 1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6];
			let whitePatternInv = [0, 2, 4, 5, 7, 9, 11];
			let blackHeightRatio = 0.65;
			function keyPath(key, height, context) {
				let blackHeight = height*blackHeightRatio;

				let floorKey = Math.floor(key);
				let fracKey = key - floorKey;
				let octKey = floorKey - (floorKey%12);
				let whiteIndex = whitePattern[floorKey%12];
				let isBlackP = blackPattern[(floorKey + 11)%12];
				let isBlack = blackPattern[floorKey%12];
				let isBlack1 = blackPattern[(floorKey + 1)%12];
				let isBlack2 = blackPattern[(floorKey + 2)%12];

				let w = 1/128, ww = w*12/7;;
				let blackX = w*floorKey;
				let whiteX = w*octKey + ww*whiteIndex; // x position of either current key (if white) or next
				let heightA = (isBlack) ? blackHeight : height;
				let heightB = (isBlack1) ? blackHeight : height;
				let vf = fracKey*fracKey*(3 - 2*fracKey);
				vf *= vf*(3 - 2*vf);
				let whiteHeight = heightA + (heightB - heightA)*vf;
				
				let t0a = blackX, t0b = t0a + w;
				let t1a = t0b, t1b = t0b + w;
				let b0a = whiteX, b0b = whiteX + ww;
				let b1a = b0b, b1b = b0b + ww;

				if (isBlack) {
					b0b = b0a;
					b1b = b1a;
				} else if (isBlack1) {
					b0b = b0a;
					b1b = b1a;
				}

				if (!isBlack && !isBlack1) {
					t1a = b1a;
					t0b = b0b;
				} else if (!isBlack && !isBlackP) {
					t0a = b0a;
				} else if (!isBlack1 && !isBlack2) {
					t1b = b1b;
				}

				if (isBlack) {
					b1a = t1a;
				} else if (isBlack1) {
					b0b = t0b;
				}

				context.beginPath();
				context.lineTo(b0a + (b0b - b0a)*fracKey, whiteHeight);
				context.lineTo(b0a + (b0b - b0a)*fracKey, blackHeight);
				context.lineTo(t0a + (t0b - t0a)*fracKey, blackHeight);
				context.lineTo(t0a + (t0b - t0a)*fracKey, 0);
				context.lineTo(t1a + (t1b - t1a)*fracKey, 0);
				context.lineTo(t1a + (t1b - t1a)*fracKey, blackHeight);
				context.lineTo(b1a + (b1b - b1a)*fracKey, blackHeight);
				context.lineTo(b1a + (b1b - b1a)*fracKey, whiteHeight);
				context.closePath();

				return isBlack + (isBlack1 - isBlack)*fracKey;
			}
			function getContext(canvas) {
				let targetWidth = Math.round(canvas.offsetWidth*window.devicePixelRatio);
				if (canvas.width != targetWidth) canvas.width = targetWidth;
				let targetHeight = Math.round(canvas.offsetHeight*window.devicePixelRatio);
				if (canvas.height != targetHeight) canvas.height = targetHeight;
				if (!targetHeight || !targetWidth) return null;
				return canvas.getContext('2d');
			}
			function getKeyboardContext(canvas) {
				let context = getContext(canvas);
				if (!context) return null;
				context.resetTransform();
				context.scale(canvas.width, canvas.width);
				return context;
			}
			function drawKeyboardBg() {
				let canvas = document.querySelector('#keyboard-bg');
				let height = canvas.height/canvas.width;

				let context = getKeyboardContext(canvas);
				if (!context) return;
				context.lineWidth = 0.0012;
				context.lineJoin = 'round';
				context.strokeStyle = '#000';
				for (let key = 0; key <= 127; ++key) {
					let blackKey = keyPath(key, height, context);

					let c = Math.round(255*key/127);
					context.fillStyle = (blackKey > 0.5) ? '#333' : '#FFF';
					context.fill();
					context.stroke();
				}
			}
			function drawKeys(keys) {
				let canvas = document.querySelector('#keyboard');
				let height = canvas.height/canvas.width;
								
				let context = getKeyboardContext(canvas);
				if (!context) return;
				context.clearRect(0, 0, canvas.width, canvas.height);
				keys.forEach(key => {
					let c = Math.round(255*key.hue);
					let c2 = Math.round(64 + 128*4*key.hue*(1 - key.hue));
					context.fillStyle = `rgba(${c}, ${c2}, ${255 - c}, 1)`;

					context.globalAlpha = Math.min(1, 0.5 + 0.5*key.brightness);
					keyPath(key.key, height, context);
					context.fill();
				});
			}

			function drawScrollOverlay() {
				let canvas = document.querySelector('#scroll-overlay');
				canvas.width = canvas.width; // clear it

				let context = getKeyboardContext(canvas);
				if (!context) return;
				context.fillStyle = '#FFF1';
				for (let k = 0; k <= 128; k += 12) {
					let x = k/128, w = 1/128;
					context.fillRect(x, 0, w, canvas.height);
					context.fill();
				}
				context.fillStyle = '#0002';
				for (let k = 0; k <= 128; ++k) {
					if (!blackPattern[k%12]) continue;
					let x = k/128, w = 1/128;
					context.fillRect(x, 0, w, canvas.height);
					context.fill();
				}
				context.strokeStyle = '#FFF1';
				context.lineWidth = 0.0005;
				for (let k = 0; k <= 128; ++k) {
					let x = k/128;
					context.beginPath();
					context.lineTo(x, 0);
					context.lineTo(x, canvas.height);
					context.stroke();
				}
			}
			let scrollSpeed = 0.1;
			let prevFrameTime = 0;
			function scrollKeys(seconds, keys) {
				let ms = Math.max(0, (seconds - prevFrameTime)*1000);
				prevFrameTime = seconds;
				let height = Math.ceil(window.devicePixelRatio*ms*scrollSpeed);
				let attackHeight = window.devicePixelRatio*2;

				let canvas = document.querySelector('#scroll');
				let context = getContext(canvas);
				if (!context) return;
				context.drawImage(canvas, 0, -height);

				context.fillStyle = '#000';
				context.fillRect(0, canvas.height - height, canvas.width, height);
				context.globalCompositeOperation = 'lighter';
				keys.forEach(key => {
					let c = Math.round(255*key.hue);
					let c2 = Math.round(64 + 128*4*key.hue*(1 - key.hue));
					context.fillStyle = `rgba(${c}, ${c2}, ${255 - c}, 1)`;
					
					let keyW = canvas.width/128;
					let x = keyW*(key.key + 0.5);
					let w2 = keyW*key.width;
					context.globalAlpha = Math.min(1, 0.25 + 0.75*key.brightness);
					context.fillRect(x - w2/2, canvas.height - height, w2, height);
					context.globalAlpha = 1;
					
					if (key.attack) {
						context.fillStyle = '#FFF';
						context.fillRect(x - keyW/2, canvas.height - Math.max(height, attackHeight), keyW, attackHeight);
						key.attack = false;
					}
				});
				context.globalCompositeOperation = 'source-over';
			}
			
			function reset() {
				drawKeyboardBg();
				drawScrollOverlay();
			}
			reset();
			addEventListener('resize', reset);
			addEventListener('DOMContentLoaded', reset);
			
			// Send FPS messages back
			let frameMs = 100, fpsPrevNow = 0;
			requestAnimationFrame(function estimateFps(){
				let now = Date.now();
				let ms = Math.min(1000, now - fpsPrevNow);
				fpsPrevNow = now;

				frameMs += (ms - frameMs)/10;
				requestAnimationFrame(estimateFps);
			});
			setInterval(_ => {
				window.parent.postMessage(CBOR.encode(1000/frameMs), '*');
			}, 100);
			
			let outputKeys = [];
			let inputKeys = [];
			function redrawKeys(scrollTime) {
				let keys = inputKeys.concat(outputKeys);
				drawKeys(keys);
				if (typeof scrollTime == 'number') {
					scrollKeys(scrollTime, keys);
				}
			}
			addEventListener('message', e => {
				let data = CBOR.decode(e.data);
				
				if (typeof data == 'object') {
					inputKeys = data.keys || [];
					redrawKeys(data.time);
				}
			});
			
			let pointerIds = {};
			let keyboard = document.querySelector('#keyboard');
			function updateKey(state, event) {
				let x = event.offsetX/keyboard.offsetWidth, y = event.offsetY/keyboard.offsetHeight;
				let floatKey = x*128;
				let key = Math.floor(floatKey);
				if (y > blackHeightRatio) {
					let octave = key - (key%12);
					let whiteKey = Math.floor((floatKey - octave)*7/12);
					key = octave + whitePatternInv[whiteKey];
				}
				if (blackPattern[key%12]) {
					y /= blackHeightRatio;
				}
				state.key = key;
				state.y = y;
				
				state.brightness = 1;
				state.width = 1;
			};
			function sendKey(state, action) {
				window.parent.postMessage(CBOR.encode({
					pointerId: state.pointerId,
					action: action,
					key: state.key,
					velocity: state.velocity
				}), '*');
			}
			keyboard.style.touchAction = 'none'; // no pan/zoom/etc.
			keyboard.addEventListener('pointerdown', e => {
				keyboard.setPointerCapture(e.pointerId);
				e.preventDefault();
				
				let state = pointerIds[e.pointerId] = pointerIds[e.pointerId] || {};
				updateKey(state, e);
				state.pointerId = e.pointerId;
				state.down = true;
				state.attack = true;
				state.velocity = state.y;
				state.hue = state.velocity;
				// Standard key properties

				outputKeys.push(state);
				redrawKeys();
				sendKey(state, "down");
			});
			keyboard.addEventListener('pointermove', e => {
				e.preventDefault();
				let state = pointerIds[e.pointerId] = pointerIds[e.pointerId] || {};
				let prevKey = state.key;
				updateKey(state, e);
				let newKey = state.key;
				if (newKey != prevKey && state.down) {
					state.key = prevKey;
					sendKey(state, "up");
					state.key = newKey;
					sendKey(state, "down");
				}
				redrawKeys();
			});
			keyboard.addEventListener('pointerup', e => {
				let state = pointerIds[e.pointerId] = pointerIds[e.pointerId] || {};
				if (state.down) {
					state.down = false;
					sendKey(state, "up");
				}
				outputKeys = Object.keys(pointerIds).map(id => pointerIds[id]).filter(s => s.down);
				redrawKeys();
			});
			keyboard.addEventListener('pointerout', e => {
				let state = pointerIds[e.pointerId];
				if (state?.down) sendKey(state, "up");
				delete pointerIds[e.pointerId];
				outputKeys = Object.keys(pointerIds).map(id => pointerIds[id]).filter(s => s.down);
				redrawKeys();
			});

			if (/[#\?]dev/.test(location.href)) {
				let startNow = Date.now();
				requestAnimationFrame(function frame() {
					let keys = [];
					for (let k = 0; k < 6; ++k) {
						keys.push({
							hue: 0.5 + 0.5*Math.cos(Date.now()*0.0001*Math.PI*(k + 0.12345)),
							brightness: 0.5 + 0.5*Math.cos(Date.now()*0.0001*Math.PI*(k + 0.25)),
							width: 0.6 + 0.4*Math.cos(Date.now()*0.0001*Math.PI*(k + 0.35)),
							key: Math.round(64 + 60*Math.cos(Date.now()*0.0001*(k + 0.5))),
							attack: (Math.random() < 0.01)
						});
					}
					window.parent.postMessage(CBOR.encode({
						time: Date.now()/1000,
						keys: keys
					}), '*');
					setTimeout(frame, frameMs); // simulate the observed framerate which the audio processor will use
				});
			}
		</script>
	</body>
</html>
